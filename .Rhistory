install.packages("devtools")
# then load
library(devtools)
install_github("mixOmicsTeam/mixOmics")
library(mixOmics)
library(igraph)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("netOmics")
library(netOmics)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
data <-readRDS("data_tcga.Rds")
data <-readRDS("data_tcga.Rds")
data_mRNA <- data$mRNA
data_miRNA <- data$miRNA
data_prot <- data$prot
data_class <- data$sample_info
Y <- data$sample_info
remove(data_class)
mRNA_splsda <- splsda(data_mRNA, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
data_class <- data$sample_info
remove(Y)
Y = data_class$Y
mRNA_splsda <- splsda(data_mRNA, Y$Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
mRNA_splsda <- splsda(data_mRNA, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
plotIndiv(mRNA_splsda , comp = 1:2,
group = Y, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = '(a) PLSDA with confidence ellipses')
plotIndiv(mRNA_splsda , comp = 1:2,
group = Y, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = 'mRNA PLSDA with confidence ellipses')
background = background.predict(srbct.splsda, comp.predicted=2, dist = "max.dist")
background = background.predict(mRNA_splsda, comp.predicted=2, dist = "max.dist")
plotIndiv(mRNA_splsda, comp = 1:2,
group = Y, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = "mRNA PLSDA with prediction background")
perf_splsda_mRNA <- perf(mRNA_splsda, validation = "Mfold",
folds = 5, nrepeat = 10, # use repeated cross-validation
progressBar = FALSE, auc = TRUE) # include AUC values
plot(perf_splsda_mRNA, col = color.mixo(5:7), sd = TRUE,
legend.position = "horizontal")
perf_splsda_mRNA$choice.ncomp # what is the optimal value of components according to perf()
list.keepX <- c(1:10,  seq(20, 300, 10))
tune.splsda.srbct <- tune.splsda(data_mRNA, Y, ncomp = 2, # calculate for first 2 components
validation = 'Mfold',
folds = 5, nrepeat = 10, # use repeated cross-validation
dist = 'max.dist', # use max.dist measure
measure = "BER", # use balanced error rate of dist measure
test.keepX = list.keepX,
cpus = 2) # allow for paralleliation to decrease runtime
plot(tune.splsda.srbct, col = color.jet(2))
tune.splsda.srbct$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
tune.splsda.srbct <- tune.splsda(data_mRNA, Y, ncomp = 4, # calculate for first 2 components
validation = 'Mfold',
folds = 5, nrepeat = 10, # use repeated cross-validation
dist = 'max.dist', # use max.dist measure
measure = "BER", # use balanced error rate of dist measure
test.keepX = list.keepX,
cpus = 2) # allow for paralleliation to decrease runtime
plot(tune.splsda.srbct, col = color.jet(4))
tune.splsda.srbct$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
tune.splsda.srbct$choice.keepX # what are the optimal values of variables according to tune.splsda()
plot(tune_splsda_mRNA, col = color.jet(4))
tune_splsda_mRNA <- tune.splsda(data_mRNA, Y, ncomp = 4, # calculate for first 2 components
validation = 'Mfold',
folds = 5, nrepeat = 10, # use repeated cross-validation
dist = 'max.dist', # use max.dist measure
measure = "BER", # use balanced error rate of dist measure
test.keepX = list.keepX,
cpus = 2) # allow for paralleliation to decrease runtime
plot(tune_splsda_mRNA, col = color.jet(4))
tune_splsda_mRNA$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
tune_splsda_mRNA$choice.keepX # what are the optimal values of variables according to tune.splsda()
tune_splsda_mRNA <- tune.splsda(data_mRNA, Y, ncomp = 2, # calculate for first 2 components
validation = 'Mfold',
folds = 5, nrepeat = 10, # use repeated cross-validation
dist = 'max.dist', # use max.dist measure
measure = "BER", # use balanced error rate of dist measure
test.keepX = list.keepX,
cpus = 2) # allow for paralleliation to decrease runtime
plot(tune_splsda_mRNA, col = color.jet(2))
tune_splsda_mRNA$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
tune_splsda_mRNA$choice.keepX # what are the optimal values of variables according to tune.splsda()
optimal.ncomp <- tune_splsda_mRNA$choice.ncomp$ncomp
optimal.keepX <- tune_splsda_mRNA$choice.keepX[1:optimal.ncomp]
remove(optimal.ncomp)
remove(optimal.keepX)
optimal_ncomp_mRNA <- tune_splsda_mRNA$choice.ncomp$ncomp
optimal_keepX_mRNA <- tune_splsda_mRNA$choice.keepX[1:optimal.ncomp]
optimal_ncomp_mRNA <- tune_splsda_mRNA$choice.ncomp$ncomp
optimal_keepX_mRNA <- tune_splsda_mRNA$choice.keepX[1:optimal_ncomp_mRNA]
final_splsda_mRNA <- splsda(data_mRNA, Y,
ncomp = optimal_ncomp_mRNA,
keepX = optimal_keepX_mRNA)
plotIndiv(final_splsda_mRNA, comp = c(1,2), # plot samples from final model
group = srbct$class, ind.names = FALSE, # colour by class label
ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
title = 'sPLS-DA on mRNA, comp 1 & 2')
plotIndiv(final_splsda_mRNA, comp = c(1,2), # plot samples from final model
group = Y, ind.names = FALSE, # colour by class label
ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
title = 'sPLS-DA on mRNA, comp 1 & 2')
plotIndiv(mRNA_splsda, comp = 1:2,
group = Y, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = "mRNA PLSDA with prediction background")
plotIndiv(mRNA_splsda , comp = 1:2,
group = Y, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = 'mRNA PLSDA with confidence ellipses')
# set the styling of the legend to be homogeneous with previous plots
legend=list(legend = levels(Y), # set of classes
col = unique(color.mixo(Y)), # set of colours
title = "Tumour Type", # legend title
cex = 0.7) # legend size
# generate the CIM, using the legend and colouring rows by each sample's class
cim <- cim(final_splsda_mRNA, row.sideColors = color.mixo(Y),
legend = legend)
# set the styling of the legend to be homogeneous with previous plots
legend=list(legend = levels(Y), # set of classes
col = unique(color.mixo(Y)), # set of colours
title = "Tumour Type", # legend title
cex = 0.7) # legend size
# generate the CIM, using the legend and colouring rows by each sample's class
cim <- cim(final_splsda_mRNA, row.sideColors = color.mixo(Y),
legend = legend)
# set the styling of the legend to be homogeneous with previous plots
legend=list(legend = levels(Y), # set of classes
col = unique(color.mixo(Y)), # set of colours
title = "Tumour Type", # legend title
cex = 0.7) # legend size
# generate the CIM, using the legend and colouring rows by each sample's class
cim <- cim(final_splsda_mRNA, row.sideColors = color.mixo(Y),
legend = legend)
?cim
plotVar(final.splsda, comp = c(1,2), var.names = list(colnames(data_mRNA)), cex = 3) # generate correlation circle plot
plotVar(final_splsda_mRNA, comp = c(1,2), var.names = list(colnames(data_mRNA)), cex = 3) # generate correlation circle plot
plotVar(final_splsda_mRNA, comp = c(1,2), var.names = list(colnames(data_mRNA)), cex = 3) # generate correlation circle plot
train <- sample(1:nrow(X), 50) # randomly select 50 samples in training
train <- sample(1:nrow(data_mRNA), 50) # randomly select 50 samples in training
test <- setdiff(1:nrow(data_mRNA), train) # rest is part of the test set
# store matrices into training and test set:
mRNA_train <- data_mRNA[train_mRNA, ]
# store matrices into training and test set:
mRNA_train <- data_mRNA[train_mRNA, ]
train_mRNA <- sample(1:nrow(data_mRNA), 50) # randomly select 50 samples in training
test_mRNA <- setdiff(1:nrow(data_mRNA), train) # rest is part of the test set
# store matrices into training and test set:
mRNA_train <- data_mRNA[train_mRNA, ]
mRNA_test <- data_mRNA[test_mRNA,]
Y_train_mRNA <- Y[mRNA_train]
# store matrices into training and test set:
mRNA_train <- data_mRNA[train_mRNA, ]
mRNA_test <- data_mRNA[test_mRNA,]
Y_train_mRNA <- Y[train_mRNA]
Y_test_mRNA <- Y[test_mRNA]
train_splsda_mRNA <- splsda(mRNA_train, Y_train_mRNA, ncomp = optimal.ncomp, keepX = optimal.keepX)
train_splsda_mRNA <- splsda(mRNA_train, Y_train_mRNA, ncomp = optimal_ncomp_mRNA, keepX = optimal_keepX_mRNA)
predict_splsda_mRNA <- predict(train_splsda_mRNA, mRNA_test,
dist = "mahalanobis.dist")
# evaluate the prediction accuracy for the first two components
predict_comp2_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,2]
table(factor(predict.comp2, levels = levels(Y)), Y_test_mRNA)
# evaluate the prediction accuracy for the first two components
predict_comp2_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,2]
table(factor(predict_comp2_mRNA, levels = levels(Y)), Y_test_mRNA)
auc_splsda_mRNA = auroc(final_splsda_mRNA, roc.comp = 1, print = FALSE) # AUROC for the first component
auc.splsda = auroc(final_splsda_mRNA, roc.comp = 2, print = FALSE) # AUROC for all three components
library(mixOmics)
library(tidyverse)
library(igraph)
library(gprofiler2)
#library(netOmics)
#library(org.Hs.eg.db)
data <- readRDS("data_tcga.Rds")
mRNa_data <- data$mRNA
prot_data <- data$prot
miRNA_data <- data$miRNA
sample_info_data <- data$sample_info
table(sample_info_data)
table(is.na(mRNa_data))
table(is.na(miRNA_data))
table(is.na(prot_data))
table(is.na(sample_info_data))
summary(as.factor(sample_info_data$Y))
boxplot(mRNa_data, col = as.factor(sample_info_data$Y), main = "boxplot mRNA")
boxplot(miRNA_data, col = as.factor(sample_info_data$Y), main = "boxplot miRNA")
boxplot(prot_data, col = as.factor(sample_info_data$Y), main = "boxplot prot")
boxplot(t(mRNa_data), col = as.factor(sample_info_data$Y), main = "boxplot sample")
data_mRNA <- mRNa_data[,colSums(mRNa_data) > 400] #on enleve 5% des val
dim(data_mRNA) # regarde dim du nouveau df : enlever 10 genes
hist(colSums((mRNa_data)))
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_mRNA <- as.numeric(lapply(data_mRNA, coef_var))
hist(coef_mRNA)
data.filtered_mRNA <- data_mRNA[,abs(coef_mRNA) > 0.15]
dim(data.filtered_mRNA)
dim(mRNa_data)
data_prot <- prot_data[,colSums(prot_data) > -95]
dim(data_prot)
hist(colSums(data_prot))
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_prot <- as.numeric(lapply(data_prot, coef_var))
hist(coef_prot)
data.filtered_prot <- data_prot[,coef_prot > -50]
dim(data.filtered_prot)
dim(prot_data)
colSums(miRNA_data)
hist(colSums(miRNA_data), breaks = 20)
#on decide de ne rien considerer comme du bruit de fond
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_miRNA <- as.numeric(lapply(as.data.frame(miRNA_data), coef_var))
hist(coef_miRNA)
data.filtered_miRNA <- miRNA_data[,coef_miRNA > 0.05]
dim(data.filtered_miRNA)
dim(miRNA_data)
data.logged_mRNA <- log(data.filtered_mRNA)
data.scaled_mRNA <- scale(data.filtered_mRNA, center = TRUE, scale = TRUE)
boxplot(data.logged_mRNA, col = as.factor(sample_info_data$Y), main = "boxplot mRNA after log")
boxplot(data.scaled_mRNA, col = as.factor(sample_info_data$Y), main = "boxplot mRNA after scale")
data.logged_prot <- log(data.filtered_prot)
data.scaled_prot <- scale(data.filtered_prot, center = TRUE, scale = TRUE)
boxplot(data.logged_prot, col = as.factor(sample_info_data$Y), main = "boxplot prot after log")
boxplot(data.scaled_prot, col = as.factor(sample_info_data$Y), main = "boxplot prot after scale")
max_mRNA <- max(coef_mRNA)
which(coef_mRNA == max_mRNA)
colnames(mRNa_data[95])
max(coef_prot)
getwd()
setwd("C:/Users/louis/Desktop/multi_omics")
saveRDS(data.scaled_mRNA, file = "mRNA_data_scaled.rds")
saveRDS(data.scaled_miRNA, file = "miRNA_data_scaled.rds")
library(mixOmics)
library(tidyverse)
library(igraph)
library(gprofiler2)
#library(netOmics)
#library(org.Hs.eg.db)
data <- readRDS("data_tcga.Rds")
mRNa_data <- data$mRNA
prot_data <- data$prot
miRNA_data <- data$miRNA
sample_info_data <- data$sample_info
table(sample_info_data)
table(is.na(mRNa_data))
table(is.na(miRNA_data))
table(is.na(prot_data))
table(is.na(sample_info_data))
summary(as.factor(sample_info_data$Y))
boxplot(mRNa_data, col = as.factor(sample_info_data$Y), main = "boxplot mRNA")
boxplot(miRNA_data, col = as.factor(sample_info_data$Y), main = "boxplot miRNA")
boxplot(prot_data, col = as.factor(sample_info_data$Y), main = "boxplot prot")
boxplot(t(mRNa_data), col = as.factor(sample_info_data$Y), main = "boxplot sample")
data_mRNA <- mRNa_data[,colSums(mRNa_data) > 400] #on enleve 5% des val
dim(data_mRNA) # regarde dim du nouveau df : enlever 10 genes
hist(colSums((mRNa_data)))
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_mRNA <- as.numeric(lapply(data_mRNA, coef_var))
hist(coef_mRNA)
data.filtered_mRNA <- data_mRNA[,abs(coef_mRNA) > 0.15]
dim(data.filtered_mRNA)
dim(mRNa_data)
data_prot <- prot_data[,colSums(prot_data) > -95]
dim(data_prot)
hist(colSums(data_prot))
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_prot <- as.numeric(lapply(data_prot, coef_var))
hist(coef_prot)
data.filtered_prot <- data_prot[,coef_prot > -50]
dim(data.filtered_prot)
dim(prot_data)
colSums(miRNA_data)
hist(colSums(miRNA_data), breaks = 20)
#on decide de ne rien considerer comme du bruit de fond
coef_var <- function(x){
c_var = sd(x)/mean(x)
}
coef_miRNA <- as.numeric(lapply(as.data.frame(miRNA_data), coef_var))
hist(coef_miRNA)
data.filtered_miRNA <- miRNA_data[,coef_miRNA > 0.05]
dim(data.filtered_miRNA)
dim(miRNA_data)
data.logged_mRNA <- log(data.filtered_mRNA)
data.scaled_mRNA <- scale(data.filtered_mRNA, center = TRUE, scale = TRUE)
boxplot(data.logged_mRNA, col = as.factor(sample_info_data$Y), main = "boxplot mRNA after log")
boxplot(data.scaled_mRNA, col = as.factor(sample_info_data$Y), main = "boxplot mRNA after scale")
data.logged_prot <- log(data.filtered_prot)
data.scaled_prot <- scale(data.filtered_prot, center = TRUE, scale = TRUE)
boxplot(data.logged_prot, col = as.factor(sample_info_data$Y), main = "boxplot prot after log")
boxplot(data.scaled_prot, col = as.factor(sample_info_data$Y), main = "boxplot prot after scale")
data.logged_miRNA <- log(data.filtered_miRNA)
data.scaled_miRNA <- scale(data.filtered_miRNA, center = TRUE, scale = TRUE)
boxplot(data.logged_miRNA, col = as.factor(sample_info_data$Y), main = "boxplot prot after log")
boxplot(data.scaled_miRNA, col = as.factor(sample_info_data$Y), main = "boxplot prot after scale")
max_mRNA <- max(coef_mRNA)
which(coef_mRNA == max_mRNA)
colnames(mRNa_data[95])
max(coef_prot)
boxplot(data.scaled_miRNA, col = as.factor(sample_info_data$Y), main = "boxplot miRNA after scale")
boxplot(data.logged_miRNA, col = as.factor(sample_info_data$Y), main = "boxplot miRNA after log")
saveRDS(data.scaled_mRNA, file = "mRNA_data_scaled.rds")
saveRDS(data.scaled_miRNA, file = "miRNA_data_scaled.rds")
saveRDS(data.scaled_prot, file = "prot_data_scaled.rds")
data_mRNA <- readRDS("mRNA_data_scaled.Rds")
data_mRNA <- as.data.frame(data_mRNA)
data_miRNA <- readRDS("miRNA_data_scaled.Rds")
data_prot <- readRDS("prot_data_scaled.Rds")
data_miRNA <- as.data.frame(data.logged_miRNA)
data_prot <- as.data.frame(data_prot)
Y = data_class$Y
mRNA_splsda <- splsda(data_mRNA, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
plotIndiv(mRNA_splsda , comp = 1:2,
group = Y, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = 'mRNA PLSDA with confidence ellipses')
data <-readRDS("data_tcga.Rds")
data_mRNA <- readRDS("mRNA_data_scaled.Rds")
data_mRNA <- as.data.frame(data_mRNA)
data_miRNA <- readRDS("miRNA_data_scaled.Rds")
data_miRNA <- as.data.frame(data.logged_miRNA)
data_prot <- readRDS("prot_data_scaled.Rds")
data_prot <- as.data.frame(data_prot)
data_class <- data$sample_info
Y = data_class$Y
mRNA_splsda <- splsda(data_mRNA, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
plotIndiv(mRNA_splsda , comp = 1:2,
group = Y, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = 'mRNA PLSDA with confidence ellipses')
background = background.predict(mRNA_splsda, comp.predicted=2, dist = "max.dist")
plotIndiv(mRNA_splsda, comp = 1:2,
group = Y, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = "mRNA PLSDA with prediction background")
perf_splsda_mRNA <- perf(mRNA_splsda, validation = "Mfold",
folds = 5, nrepeat = 10, # use repeated cross-validation
progressBar = FALSE, auc = TRUE) # include AUC values
plot(perf_splsda_mRNA, col = color.mixo(5:7), sd = TRUE,
legend.position = "horizontal")
perf_splsda_mRNA$choice.ncomp # what is the optimal value of components according to perf()
list.keepX <- c(1:10,  seq(20, 300, 10))
tune_splsda_mRNA <- tune.splsda(data_mRNA, Y, ncomp = 3, # calculate for first 3 components
validation = 'Mfold',
folds = 5, nrepeat = 10, # use repeated cross-validation
dist = 'max.dist', # use max.dist measure
measure = "BER", # use balanced error rate of dist measure
test.keepX = list.keepX,
cpus = 2) # allow for paralleliation to decrease runtime
plot(tune_splsda_mRNA, col = color.jet(3))
tune_splsda_mRNA$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
tune_splsda_mRNA$choice.keepX # what are the optimal values of variables according to tune.splsda()
optimal_ncomp_mRNA <- tune_splsda_mRNA$choice.ncomp$ncomp
optimal_keepX_mRNA <- tune_splsda_mRNA$choice.keepX[1:optimal_ncomp_mRNA]
final_splsda_mRNA <- splsda(data_mRNA, Y,
ncomp = optimal_ncomp_mRNA,
keepX = optimal_keepX_mRNA)
plotIndiv(final_splsda_mRNA, comp = c(1,2), # plot samples from final model
group = Y, ind.names = FALSE, # colour by class label
ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
title = 'sPLS-DA on mRNA, comp 1 & 2')
# set the styling of the legend to be homogeneous with previous plots
legend=list(legend = levels(Y), # set of classes
col = unique(color.mixo(Y)), # set of colours
title = "Tumour Type", # legend title
cex = 0.7) # legend size
# generate the CIM, using the legend and colouring rows by each sample's class
cim <- cim(final_splsda_mRNA, row.sideColors = color.mixo(Y),
legend = legend)
plotVar(final_splsda_mRNA, comp = c(1,2), var.names = list(colnames(data_mRNA)), cex = 3) # generate correlation circle plot
train_mRNA <- sample(1:nrow(data_mRNA), 50) # randomly select 50 samples in training
test_mRNA <- setdiff(1:nrow(data_mRNA), train) # rest is part of the test set
# store matrices into training and test set:
mRNA_train <- data_mRNA[train_mRNA, ]
mRNA_test <- data_mRNA[test_mRNA,]
Y_train_mRNA <- Y[train_mRNA]
Y_test_mRNA <- Y[test_mRNA]
train_splsda_mRNA <- splsda(mRNA_train, Y_train_mRNA, ncomp = optimal_ncomp_mRNA, keepX = optimal_keepX_mRNA)
predict_splsda_mRNA <- predict(train_splsda_mRNA, mRNA_test,
dist = "mahalanobis.dist")
# evaluate the prediction accuracy for the first two components
predict_comp2_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,2]
table(factor(predict_comp2_mRNA, levels = levels(Y)), Y_test_mRNA)
auc_splsda_mRNA = auroc(final_splsda_mRNA, roc.comp = 1, print = FALSE) # AUROC for the first component
auc.splsda = auroc(final_splsda_mRNA, roc.comp = 3, print = FALSE) # AUROC for all three components
# evaluate the prediction accuracy for the first two components
predict_comp3_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,3]
table(factor(predict_comp3_mRNA, levels = levels(Y)), Y_test_mRNA)
# evaluate the prediction accuracy for the first two components
predict_comp2_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,3]
table(factor(predict_comp2_mRNA, levels = levels(Y)), Y_test_mRNA)
# evaluate the prediction accuracy for the first two components
predict_comp2_mRNA <- predict_splsda_mRNA$class$mahalanobis.dist[,2]
table(factor(predict_comp2_mRNA, levels = levels(Y)), Y_test_mRNA)
plotIndiv(final_splsda_mRNA, comp = c(1,3), # plot samples from final model
group = Y, ind.names = FALSE, # colour by class label
ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
title = 'sPLS-DA on mRNA, comp 1 & 3')
